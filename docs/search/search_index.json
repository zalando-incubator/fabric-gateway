{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fabric Gateway \u00b6 Fabric API Gateway is an API Gateway built on Skipper . Skipper is a HTTP router which has many features which are applied on a route-by-route basis, where each route is configured by a single Ingress. Fabric API Gateway generates these ingresses to support authentication, rate-limiting and more from a single OpenAPI -style Custom Resource Definition . Getting started Features","title":"Home"},{"location":"#fabric-gateway","text":"Fabric API Gateway is an API Gateway built on Skipper . Skipper is a HTTP router which has many features which are applied on a route-by-route basis, where each route is configured by a single Ingress. Fabric API Gateway generates these ingresses to support authentication, rate-limiting and more from a single OpenAPI -style Custom Resource Definition . Getting started Features","title":"Fabric Gateway"},{"location":"fabric-gateway-features/","text":"Fabric Gateway \u00b6 Powered by Skipper , Fabric Gateway is a security-audited and scalable solution that makes it easy for developers to secure and monitor APIs at scale. The Gateway operates at the Kubernetes Ingress layer and is capable of providing the above features (and more) for all inbound traffic, so application developers don\u2019t have to. A companion Grafana dashboard allows developers to monitor their Gateway-secured APIs with fine-grained per-client performance visibility. To enable the Fabric Gateway for an application simply add this Kubernetes Custom Resource Definition (CRD) to its CDP setup (e.g., by placing in deploy/apply ). N.B. You should not have both a FabricGateway and a standard Ingress resource defined, as the default ingress would not give you any authentication but would allow traffic access to your unprotected backend service. If you are using FabricGateway to manage auth for your service, then please remove any existing ingress resources. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-admins : - bmooney - fmoloney - cgallagher - jblogs paths : /api/resource : post : x-fabric-privileges : - \"spp-application.write\" x-fabric-ratelimits : default-rate : 10 period : minute target : spp_service_name : 50 /api/resource/* : get : x-fabric-privileges : - \"spp-application.read\" put : x-fabric-privileges : - \"spp-application.write\" x-fabric-ratelimits : default-rate : 10 patch : x-fabric-privileges : - \"spp-application.write\" x-fabric-ratelimits : default-rate : 10 /events : post : x-fabric-privileges : - \"spp-application.read\" For servicePort , you must specify a named port from your service definition. If you don\u2019t specify servicePort , Fabric Gateway defaults to a port named \u2018http\u2019. Below is an example of a service with a named port: apiVersion : v1 kind : Service metadata : labels : application : \"{{ APPLICATION }}\" version : \"{{ VERSION }}\" name : \"{{ APPLICATION }}\" spec : selector : application : \"{{ APPLICATION }}\" type : ClusterIP ports : - name : http port : 80 targetPort : 8080 Gateway Features \u00b6 Currently the gateway attempts to solve the following re-occurring requirements for services: Authentication Authorization Admin Access Service Whitelisting Resource Whitelisting API Monitoring # This is now provided by default by the API Portal Encryption In Transit Rate Limiting To create a gateway for your application, you will need to include a gateway resource (sample definition below) in your deploy/apply folder. If you are using the Fabric CDP gen then this gateway resource will be generated for you. Authentication \u00b6 When using the gateway to authenticate requests to your service, there will be a header added to the request, X-TokenInfo-Forward . This will contain the uid , scope and realm retrieved from from the Token Info endpoint . Authorization \u00b6 To confirm that each authenticated token is from a valid service or employee, the gateway will implicitly add a scope check for the uid scope. Admin Access \u00b6 Team members can be added to your x-fabric-admins list. The uids in this list will have access to all endpoints and will not be subject to rate-limiting or other authentication rules. Rate Limiting \u00b6 If a client of the gateway is getting rate limited, they will get a 429 HTTP response code. There will also be some headers included to indicate when they will be able to make requests again. Below is a sample rate limited response from the gateway. The Retry-After header, shows the number of seconds before you may attempt a new request. The X-Rate-Limit header shows the number of requests per hour, which the client is allowed to make. curl -i -H \"Authorization: Bearer $FDA \" https://fgtestapp.smart-product-platform-test.zalan.do/limited/me HTTP/2 429 date: Tue, 26 Mar 2019 12 :05:51 GMT content-type: text/plain ; charset = utf-8 content-length: 18 retry-after: 53 server: Skipper x-content-type-options: nosniff x-rate-limit: 120 Encryption In Transit \u00b6 The gateway will ensure that no requests are hitting your service unless they are encrypted using https . To achieve this, we have a skipper filter on every route, which will reject the request with a 400 response if it contains the X-Forwarded-Proto: http header. This is an extra layer of security to ensure that people are not interacting with your service in an insecure manner. An example request can be seen below: curl -i -H \"Authentication: Bearer $( ztoken ) \" http://fgtestapp.smart-product-platform-test.zalan.do/resources HTTP/1.1 400 Forbidden Date: Fri, 01 Mar 2019 10 :38:05 GMT Content-Type: text/plain ; charset = utf-8 Content-Length: 104 Connection: keep-alive Server: Skipper { \"title\" : \"Gateway Rejected\" , \"status\" : 400 , \"detail\" : \"TLS is required\" , \"type\" : \"https://cloud.docs.zalando.net/howtos/ingress/#redirect-http-to-https\" } Multiple Hosts \u00b6 All created Skipper routes will match incoming requests first by their host. If you have multiple hosts for a service, then each of these needs to be listed in the gateway resource. Whitelisting \u00b6 You can define either a global or a route-level whitelist for your gateway as per the below examples. What this means is that only services whose names are defined in the whitelist will be able to interact with your service. All other access requirements, i.e. scopes and rate limits, will still apply to the whitelisted service. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-admins : - jblogs x-fabric-whitelist : - stups_some-whitelisted-service paths : /api/resource : get : x-fabric-privileges : - \"spp-application.write\" post : x-fabric-privileges : - \"spp-application.write\" # This is a more fine-grained whitelist and overrides the global whitelist. Only some-other-service can access this path. # This id is taken from the \"sub\" field of a JWT token. For a service, this value is always \"stups_\" followed by the application's Kio id. # some-whitelisted-service from the global whitelist cannot access this path. x-fabric-whitelist : service-list : - stups_some-other-service head : x-fabric-privileges : - \"spp-application.read\" # Another type of fine-grained whitelist over-ride is to disabled whitelisting altogether and allow any # service which has the correct scopes to access the route. x-fabric-whitelist : state : disabled service-list : [] /api/resource/{resource_id} : put : # This whitelist config overrides the global whitelist and because of the empty whitelist # no other service will be able to access this route. i.e. Only defined admins would be able to access the # route x-fabric-whitelist : service-list : [] Employee Whitelisting \u00b6 Employee tokens do not use scopes, so in order to allow certain employees access to an endpoint we must whitelist their uid. Note that this is different to Admin Access since admins are not subject to rate limits. In the example below, we can see that the /api/resource get endpoint can be accessed by services with the spp-application.write scope or the employee whose uid is useruid . The service and the employee will be subject to a ratelimit of 5 requests per minute. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http paths : /api/resource : get : x-fabric-privileges : - \"spp-application.write\" x-fabric-employee-access : user-list : - useruid x-fabric-ratelimits : default-rate : 5 CORS Support \u00b6 For browser applications to communicate directly with an API, the API needs to support Cross-Origin Resource Sharing . The Gateway supports this by automatically adding an OPTIONS endpoint to each of your paths to handle browser Preflight Requests . The origins and headers you configure will be allowed in the response headers. Additionally, configuring cors support causes the Access-Control-Allow-Origin header to contain the request\u2019s Origin if you have whitelisted it here. Note: We do not allow * to be used as an allowed origin. Every Gateway API will want to allow the Authorization and Content-Type headers here, to allow auth tokens and the application/json Content-Type to be used. In the example below, they gateway will generate an OPTIONS route for the /api/resources path. This will support preflighted requests for your listed HTTP verbs, allowedOrigins and allowedHeaders . Once the preflight is done, the actual request will also automatically have the right Access-Control-Allow-Origin header if the request Origin is allowed. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-cors-support : allowedOrigins : - example.com - example-other.com allowedHeaders : - Authorization - Content-Type - X-Flow-Id paths : /api/resource : get : x-fabric-privileges : - \"spp-application.write\" Other \u00b6 Path Matching \u00b6 There are some rules around path matching in the gateway which are outlined below. Dynamic path segments should be represented by either a * or a {named} parameter Wildcard matching of multiple path segments can be performed by using ** , the ** must be the last part of the path Examples of some valid and invalid paths are outlined below: apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-admins : - jblogs paths : # This is an exact path match. The only URI that will be matched is a GET request against `/api/resource` /api/resource : get : x-fabric-privileges : - \"spp-application.read\" # Match a path which has a dynamic segment. This will match any identifer for the resource # e.g. /api/resource/123 /api/resource/abc-123 etc... # However this will only match a single path segment so the below would not be matched # /api/resource/123/sub-resource /api/resource/* : get : x-fabric-privileges : - \"spp-application.read\" # This is the exact same as the above dynamic segment matching, except that the segment is named. # The name of the segment currently has no extra significance /api/resource/{resource_id} : get : x-fabric-privileges : - \"spp-application.read\" # The double * is a wildcard match. This wildcard will match across multiple segments in the URI # For example the following paths would be successfully matched: # e.g. /api/someresource/123 /api/someresource/123/sub-resource /api/someresource/123/sub-resource/123 /api/someresource/** : get : x-fabric-privileges : - \"spp-application.read\" # There is a requirement for ** to be at the end of the path. The below path key would be considered # invalid /api/someresource/**/subkey : get : x-fabric-privileges : - \"spp-application.read\" Gateway Generation \u00b6 A fabric gateway definition can be generated by sending your Open API Specification aka OAS to the fabric resource generator. This service queries the Teams Api and returns a gateway based on your OAS which is enriched with an admins list containing all the members on your team. Example of the curl request needed to use this service: curl -i --data-binary @yourOAS.yaml -H 'Content-Type: application/x-yaml' -H \"Authorization: Bearer $( ztoken ) \" -X POST https://fabric-resource-generator.smart-product-platform.zalan.do/api/gateways","title":"Features"},{"location":"fabric-gateway-features/#fabric-gateway","text":"Powered by Skipper , Fabric Gateway is a security-audited and scalable solution that makes it easy for developers to secure and monitor APIs at scale. The Gateway operates at the Kubernetes Ingress layer and is capable of providing the above features (and more) for all inbound traffic, so application developers don\u2019t have to. A companion Grafana dashboard allows developers to monitor their Gateway-secured APIs with fine-grained per-client performance visibility. To enable the Fabric Gateway for an application simply add this Kubernetes Custom Resource Definition (CRD) to its CDP setup (e.g., by placing in deploy/apply ). N.B. You should not have both a FabricGateway and a standard Ingress resource defined, as the default ingress would not give you any authentication but would allow traffic access to your unprotected backend service. If you are using FabricGateway to manage auth for your service, then please remove any existing ingress resources. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-admins : - bmooney - fmoloney - cgallagher - jblogs paths : /api/resource : post : x-fabric-privileges : - \"spp-application.write\" x-fabric-ratelimits : default-rate : 10 period : minute target : spp_service_name : 50 /api/resource/* : get : x-fabric-privileges : - \"spp-application.read\" put : x-fabric-privileges : - \"spp-application.write\" x-fabric-ratelimits : default-rate : 10 patch : x-fabric-privileges : - \"spp-application.write\" x-fabric-ratelimits : default-rate : 10 /events : post : x-fabric-privileges : - \"spp-application.read\" For servicePort , you must specify a named port from your service definition. If you don\u2019t specify servicePort , Fabric Gateway defaults to a port named \u2018http\u2019. Below is an example of a service with a named port: apiVersion : v1 kind : Service metadata : labels : application : \"{{ APPLICATION }}\" version : \"{{ VERSION }}\" name : \"{{ APPLICATION }}\" spec : selector : application : \"{{ APPLICATION }}\" type : ClusterIP ports : - name : http port : 80 targetPort : 8080","title":"Fabric Gateway"},{"location":"fabric-gateway-features/#gateway-features","text":"Currently the gateway attempts to solve the following re-occurring requirements for services: Authentication Authorization Admin Access Service Whitelisting Resource Whitelisting API Monitoring # This is now provided by default by the API Portal Encryption In Transit Rate Limiting To create a gateway for your application, you will need to include a gateway resource (sample definition below) in your deploy/apply folder. If you are using the Fabric CDP gen then this gateway resource will be generated for you.","title":"Gateway Features"},{"location":"fabric-gateway-features/#authentication","text":"When using the gateway to authenticate requests to your service, there will be a header added to the request, X-TokenInfo-Forward . This will contain the uid , scope and realm retrieved from from the Token Info endpoint .","title":"Authentication"},{"location":"fabric-gateway-features/#authorization","text":"To confirm that each authenticated token is from a valid service or employee, the gateway will implicitly add a scope check for the uid scope.","title":"Authorization"},{"location":"fabric-gateway-features/#admin-access","text":"Team members can be added to your x-fabric-admins list. The uids in this list will have access to all endpoints and will not be subject to rate-limiting or other authentication rules.","title":"Admin Access"},{"location":"fabric-gateway-features/#rate-limiting","text":"If a client of the gateway is getting rate limited, they will get a 429 HTTP response code. There will also be some headers included to indicate when they will be able to make requests again. Below is a sample rate limited response from the gateway. The Retry-After header, shows the number of seconds before you may attempt a new request. The X-Rate-Limit header shows the number of requests per hour, which the client is allowed to make. curl -i -H \"Authorization: Bearer $FDA \" https://fgtestapp.smart-product-platform-test.zalan.do/limited/me HTTP/2 429 date: Tue, 26 Mar 2019 12 :05:51 GMT content-type: text/plain ; charset = utf-8 content-length: 18 retry-after: 53 server: Skipper x-content-type-options: nosniff x-rate-limit: 120","title":"Rate Limiting"},{"location":"fabric-gateway-features/#encryption-in-transit","text":"The gateway will ensure that no requests are hitting your service unless they are encrypted using https . To achieve this, we have a skipper filter on every route, which will reject the request with a 400 response if it contains the X-Forwarded-Proto: http header. This is an extra layer of security to ensure that people are not interacting with your service in an insecure manner. An example request can be seen below: curl -i -H \"Authentication: Bearer $( ztoken ) \" http://fgtestapp.smart-product-platform-test.zalan.do/resources HTTP/1.1 400 Forbidden Date: Fri, 01 Mar 2019 10 :38:05 GMT Content-Type: text/plain ; charset = utf-8 Content-Length: 104 Connection: keep-alive Server: Skipper { \"title\" : \"Gateway Rejected\" , \"status\" : 400 , \"detail\" : \"TLS is required\" , \"type\" : \"https://cloud.docs.zalando.net/howtos/ingress/#redirect-http-to-https\" }","title":"Encryption In Transit"},{"location":"fabric-gateway-features/#multiple-hosts","text":"All created Skipper routes will match incoming requests first by their host. If you have multiple hosts for a service, then each of these needs to be listed in the gateway resource.","title":"Multiple Hosts"},{"location":"fabric-gateway-features/#whitelisting","text":"You can define either a global or a route-level whitelist for your gateway as per the below examples. What this means is that only services whose names are defined in the whitelist will be able to interact with your service. All other access requirements, i.e. scopes and rate limits, will still apply to the whitelisted service. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-admins : - jblogs x-fabric-whitelist : - stups_some-whitelisted-service paths : /api/resource : get : x-fabric-privileges : - \"spp-application.write\" post : x-fabric-privileges : - \"spp-application.write\" # This is a more fine-grained whitelist and overrides the global whitelist. Only some-other-service can access this path. # This id is taken from the \"sub\" field of a JWT token. For a service, this value is always \"stups_\" followed by the application's Kio id. # some-whitelisted-service from the global whitelist cannot access this path. x-fabric-whitelist : service-list : - stups_some-other-service head : x-fabric-privileges : - \"spp-application.read\" # Another type of fine-grained whitelist over-ride is to disabled whitelisting altogether and allow any # service which has the correct scopes to access the route. x-fabric-whitelist : state : disabled service-list : [] /api/resource/{resource_id} : put : # This whitelist config overrides the global whitelist and because of the empty whitelist # no other service will be able to access this route. i.e. Only defined admins would be able to access the # route x-fabric-whitelist : service-list : []","title":"Whitelisting"},{"location":"fabric-gateway-features/#employee-whitelisting","text":"Employee tokens do not use scopes, so in order to allow certain employees access to an endpoint we must whitelist their uid. Note that this is different to Admin Access since admins are not subject to rate limits. In the example below, we can see that the /api/resource get endpoint can be accessed by services with the spp-application.write scope or the employee whose uid is useruid . The service and the employee will be subject to a ratelimit of 5 requests per minute. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http paths : /api/resource : get : x-fabric-privileges : - \"spp-application.write\" x-fabric-employee-access : user-list : - useruid x-fabric-ratelimits : default-rate : 5","title":"Employee Whitelisting"},{"location":"fabric-gateway-features/#cors-support","text":"For browser applications to communicate directly with an API, the API needs to support Cross-Origin Resource Sharing . The Gateway supports this by automatically adding an OPTIONS endpoint to each of your paths to handle browser Preflight Requests . The origins and headers you configure will be allowed in the response headers. Additionally, configuring cors support causes the Access-Control-Allow-Origin header to contain the request\u2019s Origin if you have whitelisted it here. Note: We do not allow * to be used as an allowed origin. Every Gateway API will want to allow the Authorization and Content-Type headers here, to allow auth tokens and the application/json Content-Type to be used. In the example below, they gateway will generate an OPTIONS route for the /api/resources path. This will support preflighted requests for your listed HTTP verbs, allowedOrigins and allowedHeaders . Once the preflight is done, the actual request will also automatically have the right Access-Control-Allow-Origin header if the request Origin is allowed. apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-cors-support : allowedOrigins : - example.com - example-other.com allowedHeaders : - Authorization - Content-Type - X-Flow-Id paths : /api/resource : get : x-fabric-privileges : - \"spp-application.write\"","title":"CORS Support"},{"location":"fabric-gateway-features/#other","text":"","title":"Other"},{"location":"fabric-gateway-features/#path-matching","text":"There are some rules around path matching in the gateway which are outlined below. Dynamic path segments should be represented by either a * or a {named} parameter Wildcard matching of multiple path segments can be performed by using ** , the ** must be the last part of the path Examples of some valid and invalid paths are outlined below: apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-app-gateway spec : x-fabric-service : - host : my-app.smart-product-platform-test.zalan.do serviceName : my-app-service-name servicePort : http x-fabric-admins : - jblogs paths : # This is an exact path match. The only URI that will be matched is a GET request against `/api/resource` /api/resource : get : x-fabric-privileges : - \"spp-application.read\" # Match a path which has a dynamic segment. This will match any identifer for the resource # e.g. /api/resource/123 /api/resource/abc-123 etc... # However this will only match a single path segment so the below would not be matched # /api/resource/123/sub-resource /api/resource/* : get : x-fabric-privileges : - \"spp-application.read\" # This is the exact same as the above dynamic segment matching, except that the segment is named. # The name of the segment currently has no extra significance /api/resource/{resource_id} : get : x-fabric-privileges : - \"spp-application.read\" # The double * is a wildcard match. This wildcard will match across multiple segments in the URI # For example the following paths would be successfully matched: # e.g. /api/someresource/123 /api/someresource/123/sub-resource /api/someresource/123/sub-resource/123 /api/someresource/** : get : x-fabric-privileges : - \"spp-application.read\" # There is a requirement for ** to be at the end of the path. The below path key would be considered # invalid /api/someresource/**/subkey : get : x-fabric-privileges : - \"spp-application.read\"","title":"Path Matching"},{"location":"fabric-gateway-features/#gateway-generation","text":"A fabric gateway definition can be generated by sending your Open API Specification aka OAS to the fabric resource generator. This service queries the Teams Api and returns a gateway based on your OAS which is enriched with an admins list containing all the members on your team. Example of the curl request needed to use this service: curl -i --data-binary @yourOAS.yaml -H 'Content-Type: application/x-yaml' -H \"Authorization: Bearer $( ztoken ) \" -X POST https://fabric-resource-generator.smart-product-platform.zalan.do/api/gateways","title":"Gateway Generation"},{"location":"fabric-gateway-getting-started/","text":"Getting Started \u00b6 The Gateway depends on metacontroller and Skipper Ingress . Once you have installed both of those, the gateway can be installed by applying some yaml. Install Metacontroller \u00b6 You can find instructions at metacontroller Install Skipper Ingress \u00b6 You can find instructions at Skipper Ingress Install API Gateway Operator \u00b6 kubectl apply -f https://raw.githubusercontent.com/zalando-incubator/fabric-gateway/master/docs/installation/basic-install.yaml Worked Example \u00b6 Apply a Sample App \u00b6 Apply the following yaml to get a sample echo app up and running: kind : Service apiVersion : v1 metadata : name : my-first-gateway spec : selector : app : my-first-gateway ports : - name : http port : 80 targetPort : 5678 --- apiVersion : apps/v1 kind : Deployment metadata : name : my-first-gateway labels : app : my-first-gateway spec : replicas : 1 selector : matchLabels : app : my-first-gateway template : metadata : labels : app : my-first-gateway spec : containers : - name : my-first-gateway image : hashicorp/http-echo:0.2.3 args : - -text=\"some string\" ports : - containerPort : 5678 Apply a Sample Gateway \u00b6 Once everything is set up, you can apply the gateway as follows: apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-first-gateway spec : x-fabric-service : - host : my-first-gateway.<mydomain.org> serviceName : my-first-gateway servicePort : http paths : /test : get : x-fabric-privileges : - uid Now run this to get an authentication failure: curl -i \"https:// ${ USER } -gateway-test.playground.zalan.do/somepath\" If your token has the right scopes, the following will give a successful response: curl -i -H \"Authorization: Bearer ${ TOKEN } \" \"https:// ${ USER } -gateway-test.playground.zalan.do/somepath\"","title":"Getting Started"},{"location":"fabric-gateway-getting-started/#getting-started","text":"The Gateway depends on metacontroller and Skipper Ingress . Once you have installed both of those, the gateway can be installed by applying some yaml.","title":"Getting Started"},{"location":"fabric-gateway-getting-started/#install-metacontroller","text":"You can find instructions at metacontroller","title":"Install Metacontroller"},{"location":"fabric-gateway-getting-started/#install-skipper-ingress","text":"You can find instructions at Skipper Ingress","title":"Install Skipper Ingress"},{"location":"fabric-gateway-getting-started/#install-api-gateway-operator","text":"kubectl apply -f https://raw.githubusercontent.com/zalando-incubator/fabric-gateway/master/docs/installation/basic-install.yaml","title":"Install API Gateway Operator"},{"location":"fabric-gateway-getting-started/#worked-example","text":"","title":"Worked Example"},{"location":"fabric-gateway-getting-started/#apply-a-sample-app","text":"Apply the following yaml to get a sample echo app up and running: kind : Service apiVersion : v1 metadata : name : my-first-gateway spec : selector : app : my-first-gateway ports : - name : http port : 80 targetPort : 5678 --- apiVersion : apps/v1 kind : Deployment metadata : name : my-first-gateway labels : app : my-first-gateway spec : replicas : 1 selector : matchLabels : app : my-first-gateway template : metadata : labels : app : my-first-gateway spec : containers : - name : my-first-gateway image : hashicorp/http-echo:0.2.3 args : - -text=\"some string\" ports : - containerPort : 5678","title":"Apply a Sample App"},{"location":"fabric-gateway-getting-started/#apply-a-sample-gateway","text":"Once everything is set up, you can apply the gateway as follows: apiVersion : zalando.org/v1 kind : FabricGateway metadata : name : my-first-gateway spec : x-fabric-service : - host : my-first-gateway.<mydomain.org> serviceName : my-first-gateway servicePort : http paths : /test : get : x-fabric-privileges : - uid Now run this to get an authentication failure: curl -i \"https:// ${ USER } -gateway-test.playground.zalan.do/somepath\" If your token has the right scopes, the following will give a successful response: curl -i -H \"Authorization: Bearer ${ TOKEN } \" \"https:// ${ USER } -gateway-test.playground.zalan.do/somepath\"","title":"Apply a Sample Gateway"}]}